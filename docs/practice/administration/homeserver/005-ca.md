# Локальный центр сертификации

https://sysadminium.ru/create-own-certificate-authority-on-linux/ (openssl)

https://www.digitalocean.com/community/tutorials/how-to-set-up-and-configure-a-certificate-authority-ca-on-ubuntu-20-04-ru (easy-rsa)

Для создания ssl/tls сертификатов можно использовать утилиту openssl, или набор скриптов easy-rsa.

---

## Вводные данные

Сервер на котором создают корневые сертификаты, а затем с их помощью выпускают сертификаты для доменов называют – центр сертификации. Он занимается импортом, подписанием и отзывом сертификатов.

При помощи сертификатов можно удостовериться в истинности факта, что источник информации тот, за кого он себя выдаёт (_но это не точно_). Бывают публичные центры сертификации и частные. Публичные удостоверяют, что тому или иному домену вполне можно доверять. К их услугам прибегают, когда сайт переходит на использование протокола HTTPS. Частные же ЦА нужны в локальных сетях для тестовых целей (разработка сайтов, dev-домен которых использует схему _"https://"_), устройства VPN-туннелей и также для безопасности (когда сеть очень большая).

В этой системе используется протокол TLS. Он предполагает асинхронное шшифрование. То есть создаётся пара ключей: один ключ может зашифровать, другой может расшифровать и наоборот.

- закрытый ключ – это обычный ключ шифрования применяемый в асинхронном шифровании.
- открытый ключ – это тоже ключ шифрования. Но он дополнительно содержит некоторую информацию, например имя домена, имя организации и другое. Такой ключ называют сертификатом.

А ещё протокол TLS позволяет создавать цепочки сертификатов. То-есть, если браузер доверяет родительскому сертификату, то он автоматически будет доверять и всем дочерним сертификатам. А чтобы создать дочернюю пару ключей, нужно иметь доступ к родительской паре ключей.

Корневая пара ключей обычно не подтверждает никакой домен. Обычно, когда создают ssl-сертификат для домена, то для безопасности отнимают у него право создания дочерних сертификатов. Корневой ключ обычно защищают паролем. Это уже симметричное шифрование, когда зная один ключ (пароль) можно зашифровать и расшифровать файл закрытого ключа.

Одним из основных требований является устройство ЦА на отдельной виртуальной или физической машине

## Установка, настройка и порядок использования систем

### Условности

Установку системы я буду производить на сервере **_bast_**, на котором уже установлен DNS, а в последствии будет установлен и файервол, и Nginx Proxy.

### easy-rsa

Данный пакет - это набор скриптов для запуска на сервере ЦС. Он позволяет создать каркас [инфраструктуры открытых ключей](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D1%80%D0%B0%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D1%85_%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B9) (PKI) на сервере ЦС.

Тактика такая: устанавливаем пакет, создаём символические ссылки из `/usr/share/easy-rsa/` в рабочий каталог и меняем права на файлы и каталоги в нём, а далее переходим к созданию ЦС. Для этого генерируем корневой сертификат.

Обновляемся и устанавливаем пакеты:

```shell
sudo apt update
sudo apt install easy-rsa
```

Использовать `sudo` при работе с этими скриптами нельзя для того, чтобы обычные пользователи должны использовать ЦС без повышения уровня прав пользователя.

Создаём рабочий каталог, делаем символические ссылки и даём ему корректные права:

```shell
mkdir ~/easy-rsa
ln -s /usr/share/easy-rsa/* ~/easy-rsa/
chmod 700 /home/sammy/easy-rsa
```

Инициализируем PKI в рабочей директории:

```shell
cd ~/easy-rsa
./easyrsa init-pki
```

После выполнения указаний этого раздела у нас будет директория, содержащая все необходимые файлы для создания Центра сертификации. Стоит заметить, что таким образом мы можем затереть все

#### Создание ЦС

Создаём файл `~/easy-rsa/vars`. Прописываем в нём следующие параметры:

```shell
set_var EASYRSA_REQ_COUNTRY    "RU"
set_var EASYRSA_REQ_PROVINCE   "Samara Region"
set_var EASYRSA_REQ_CITY       "Samara"
set_var EASYRSA_REQ_ORG        "My Firm LLC."
set_var EASYRSA_REQ_EMAIL      "admin@example.com"
set_var EASYRSA_REQ_OU         "My Firm's Organizational Unit"
set_var EASYRSA_ALGO           "ec"
set_var EASYRSA_CURVE          "secp384r1"
set_var EASYRSA_DIGEST         "sha256"
set_var EASYRSA_CA_EXPIRE      3650
```

Больше о параметрах и более расширенныйфайл `vars` [здесь](https://www.easycoding.org/2017/07/24/podnimaem-ovn-server-na-fedora.html).

Собственно, генерируем корневой сетрификат:

```shell
./easyrsa build-ca
```

Мастер потребует установить пароль для защиты секретного ключа корневого сертификата. Это нужно сделать обязательно. Данный пароль в дальнейшем будет запрашиваться для подписи других сертификатов. Если допустимо в дальнейшем не запрашивать пароль в таких случаях, то можно выполнить команду:

```shell
./easyrsa build-ca nopass
```

И в том и другом случае у нас будут получены среди прочего два ключа:

- `~/easy-rsa/pki/ca.crt` - собственно, сертификат или публичный ключ
- `~/easy-rsa/pki/private/ca.key` - приватный ключ

#### Распространение публичного сертификата Центра сертификации

Каждый пользователь или сервер, которому потребуется подтвердить подлинность другого пользователя или сервера в вашей сети, должен иметь копию файла `ca.crt`, импортированную в хранилище сертификатов его операционной системы. Это хранилище, как правило в Debian располагается в `/usr/local/share/ca-certificates/`, а в RedHat - `/etc/pki/ca-trust/source/anchors/`

| Семейство | Путь к хранилищу                    |  Команда для применения  |
| :-------- | :---------------------------------- | :----------------------: |
| Debian    | `/usr/local/share/ca-certificates/` | `update-ca-certificates` |
| RedHat    | `/etc/pki/ca-trust/source/anchors/` |    `update-ca-trust`     |

#### Создание запросов на подписание сертификатов и отзыв сертификатов

CSR (**_Certificate signing request_**) состоит из трёх частей:

- открытого ключа
- идентификационной информации запрашивающей системы
- подписи запроса, создаваемой на основе закрытого ключа запрашивающей системы

Закрытый ключ можно будет использовать для шифрования информации, которую сможет расшифровать любой пользователь с подписанным открытым сертификатом.

1. Создаём каталог для ключей доменов
2. Генерируем закрытый ключ `openssl genrsa -out name-of-domain.key`
3. Создаём CSR при помощи созданного нами закрытого ключа `openssl req -new -key name-of-domain.key -out name-of-domain.req`
   Чтобы проверить содержимое CSR, можно прочитать файл запроса командой:
   `openssl req -in name-of-domain.req -noout -subject`
4. Копируем CSR **на сервер ЦС** `scp name-of-domain.req username@your_ca_server_ip:/tmp/name-of-domain.req`
5. Подписание (**на сервере ЦС**) - импортируем запрос сертификата при помощи скрипта `easy-rsa`: `./easyrsa import-req /tmp/name-of-domain.req name-of-domain`
6. Подписание (**на сервере ЦС**) - подписываем запрос скриптом `easy-rsa` с указанием типа запроса. Запрос может иметь тип `client`, `server` или `ca`: `./easyrsa sign-req server name-of-domain`

Таким образом нами был подписан CSR `name-of-domain.req` при помощи ключа сервера ЦС, который находится в нашем случае в `~/easy-rsa/pki/private/ca.key`. Мы же получили файл `name-of-domain.crt`.

Для примера приведём случай, при котором нам нужно настроить прослушку порта 443 на Nginx. В самом минимальном случае нам нужно сделать следующую запись в конфиге нашего домена:

```nginx
# пусть это будет сервер по умолчанию с файами в каталоге по умолчанию
listen 443 ssl default_server;
        listen [::]:443 ssl default_server;
        server_name  name-of-domain.ru;

        ssl on;

        ssl_certificate /etc/ssl/name-of-domain.crt;
        ssl_certificate_key /etc/ssl/name-of-domain.key;
        root /var/www/html;
```

То есть, чтобы у нас появилась заветная отметка о защищённости сайта, нужно добавить файл, который нам выдал ЦС (`*.crt`) и файл закрытого ключа, который мы сгенерировали в начале (`*.key`) в каталог `/etc/ssl/`

Подробнее о настройке доменов на Nginx [здесь](https://nginx.org/ru/docs/http/configuring_https_servers.html) и [здесь](https://help.reg.ru/support/ssl-sertifikaty/3-etap-ustanovka-ssl-sertifikata/kak-nastroit-ssl-sertifikat-na-nginx)

Последним шагом служит отправка корневого сертификата
