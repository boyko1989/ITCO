# Установка и настройка Xubuntu

## Вводные данные

1. Железо
2. Назначение
3. Причины выбора Xubuntu

## Установка

1. Разбиение и распределение под точки монтирования разделов и дисков.
2. Выбор файловых систем (ext4 - лучший вариант для SSD)
3. Отказ от swap

### Проблемы

## Настройка

Хорошая [статья](https://wiki.dieg.info/xfce)

Очень настоятельно советую в качестве домашнего каталога пользователя заводить пустой каталог. Всю же информацию лучше каким-либо образом резервировать и восстанавливать по мере необходимости. У меня произошёл достаточно неприятный эффект, который отнял у меня много времени. После примонтирования моего домашнего каталога, который находился у меня на другом диске, установленный Google Chrome запускался, но не отображался. Что я только не делал, но проблему ничего не решало. В конце концов я сделал _rsync_-ом бэкап и почистил домашнюю папку.

Конечно, можно было очистить только каталоги `~/.cache`, `~/.config` и `~/.local`, чтобы потом, для восстановления привычного реима работы программ, закидывать в `~/.config` файлы интересующих пакетов, но я решил заодно навести порядок.

### Настройка сети

По умолчанию Xubuntu находит в сети DHCP сервер и запрашивает у него IP-адрес. Но мы установим статичесий адрес. Причём сделаем это и для Ethernet интерфейса и для Wi-Fi. В Xubuntu сеть настраивается через Netplan, поэтому открываем файл `/etc/netplan/config.yaml`. Прописываем в нём следующую конфигурацию:

```shell
network:
  ethernets:
    enp2s0f0:
      addresses:
        - 192.168.2.101/21
      routes:
        - to: default
          via: 192.168.0.1
      nameservers:
        addresses:
          - 192.168.0.1
          - 77.88.8.88
          - 77.88.8.2
        search: [boykos.local]
  wifis:
    wlp3s0:
      dhcp4: no
      dhcp6: no
      addresses:
        - 192.168.2.102/21
      nameservers:
        addresses:
          - 192.168.0.1
          - 77.88.8.88
          - 77.88.8.2
      access-points:
        "Your_wifis_SSID":
          password: "password"
  version: 2
  renderer: NetworkManager
```

### Оптимизации для работы с SSD

Они состоят в выборе правильной файловой системы, переносе с SSD подкачки и настройки триммирования. Первое и второе было сделано в процессе установки, а триммированием сейчас займёмся.

Что такое триммирование? Это применение метода TRIMM) Этот метод проверяет какие ячейки уже не содержатся в файловой системе и могут быть использованы накопителем для физического удаления. Это позволяет выровнять износ по всему пространству накопителя. По умолчанию эта операция проводится раз в неделю, но мы сделаем так, чтобы она проходила ежедневно.

Проверяем установки таймера:

```shell
sudo systemctl cat fstrim.timer
```

В параметре `OnCalendar=` мы можем увидеть текущее значение. Нам нужно добавить в этот файл ещё один параметр `OnCalendar=`, но уже со значением `daily`. Поэтому делаем так:

```shell
sudo mkdir -v /etc/systemd/system/fstrim.timer.d
sudo vim /etc/systemd/system/fstrim.timer.d/override.conf

# В последнем дописываем следующее

[Timer]
OnCalendar=
OnCalendar=daily

# Применяем изменения

sudo systemctl daemon-reload
```

Ещё раз выводим файл таймера и удостоверяемся, что он был изменён.

### FSTAB

В моей конфигурации оборудования предполагается, что система установлена на SSD диск, а домашняя папка пользователя - на HDD. Таким образом для того, чтобы я мог пользоваться свои каталогом и для повышения времени жизни SSD, нужно примонтировать некоторые каталоги определённым образом. В этом поможет редактирование файла `/etc/fstab`.

#### Монтирование домашнего каталога

Так как мой `$HOME` отформатирован в ext4, то я и не стал особо изгаляться и сделал запись по умолчанию для данной файловой системы. Хотя можно прописать правила для назначения прав и пользователей, но практика показывает, что всё это очень больно бьёт по функционалу: то права не переназначишь, то пользователь отдельных каталогов слетает после перезагрузки. Поэтому сначала определяем при помощи `lsblk` с именем устройства, на котором расположен наш будущий $HOME, а потом стремимся в `/etc/fstab` записать следующую строку:

```shell
UUID=xxx /home  ext4  defaults  0 0
```

Как узнать, а главное перенести в `/etc/fstab` UUID? Воспользуемся командой `sudo blkid /dev/sdX`

Подробнее о работе с `/etc/fstab` у меня расписано [здесь](fstab.md)

Да, может возникнуть вопрос: "Зачем ставить SSD, если всё равно $HOME на HDD?" Да, это правильный вопрос, но меня вполне устраивала скорость работы системы после загрузки, а вот ЗАГРУЗКА... После установки SSD, загрузка перестала быть бесконечной, и даже до установки 16 ГБ ОЗУ система начала работать быстрее.

#### Монтирование каталога `/tmp`

Данный каталог перезаписывается при каждой перезагрузке системы. Поэтому при использовании SSD-накопителя для системы, было бы разумно перенести этот каталог на другое устройство. Конечно, можно выделить область на HDD, но так как у нас очень много оперативной памяти, то некоторую её часть я выделю для каталога `/tmp`.

Для того, чтобы удостовериться в размере оперативки, воспользуемся командой `sudo dmidecode --type 17 | grep -i size | awk '{print $2}'`. Складываем значения и получаем количество "гигов".

Устройством, которое в Linux представяет собой оперативную память является `/dev/shm`. Проверив его размер командой `df -h /dev/shm` можно удивиться, что размер там в два раза меньше, чем общий объём наших считанных планок.

Смонтируем `tmpfs` в RAM:

```shell
sudo echo -e 'tmpfs\t/dev/shm\ttmpfs\tdefaults,size=2G\t0\t0' >> /etc/fstab
```

Затем выделенный RAM выделим на `/tmp`

```shell
sudo echo -e 'tmpfs\t/tmp\ttmpfs\trw,nodev,nosuid,size=2G\t0\t0' >> /etc/fstab
```

Перезагружаемся и работаем с уже корректно смонтрованными каталогами.

### Установка пакетов

Разделим пакеты на те, что есть в репозиториях дистрибутива, те, которые устанавливаются из своих репозиториев, и те, которые устанавливаются из deb-пакетов.

#### Установка пакетов из репозитория

Дам большую команду, которая позволит установить все требуемые мне пакеты:

```shell
sudo apt install software-properties-common apt-transport-https htop zip unzip tar curl wget rsync git mc tilda tilix tmux openssh-server vim bluefish mousepad okular speedcrunch rhythmbox libfuse2 zsh fonts-powerline qbittorrent
```

#### Пакеты из сторонних репозиториев

К таким в первую очередь отнесём Google Chrome, VS Code. Как номенклатуру продуктов, к которой нуже особый подход, будем воспринимать JetBrains Toolbox.

Рассмотрим общий порядок работы со сторонними пакетами.

- загрузить ключ репозитория
- добавить сам репозиторий
- обновить список пакетов

> Команды для работы с репозиториями и ключами [здесь](key-work.md)

##### Google Chrome

**_Подготовка и условия_**

Скажу сразу, что при установке этого браузера у меня происходило странное явление, вернее сказать полное отсутствие каких-либо ожидаемых явлений при вызове установленного пакета `google-chrome-stable`.

Первым делом я пыался исправить ситуацию тем, что удалял браузер с корнем: `sudo apt purge google-chrome-stable` и ручным затиранием каталога конфигурации в домашней директории: `rm -rf ~/.config/google-chrome`

**_Установка_**

К сожалению на данный момент я несмог найти руководство по установке брауера так чтобы **_apt_** потом не плевался варнингами о Deprecated методах. Поэтому я просто зашёл на официальный сайт программы и скачал deb-пакет, который установил командой `sudo dpkg -i google-chrome-stable_current_amd64.deb`

##### VS Code

**_Установка_**

Добавляем GPG-ключ в хранилище

```shell
curl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --dearmor -o /usr/share/keyrings/ms-vscode-keyring.gpg
```

Добавляем репозиторий Microsoft:

```shell
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/ms-vscode-keyring.gpg] https://packages.microsoft.com/repos/vscode stable main" | sudo tee /etc/apt/sources.list.d/vscode.list
```

Обновляем информацию в репозитории и устанавливаем VS Code:

```shell
sudo apt update
sudo apt install -y code
```

**_Настройка_**

После авторизации VS Code сам подгрузит конфигурации. Они будут находиться в каталоге `~/.config/Code/User/` в формате JSON. В случае, если последняя конфигурация была неудачной, а имеются конфиги с лучшим состоянием, то нужно перекинуть только их в указанную папку. Вот их список:

- keybindings.json
- settings.json
- syncLocalSettings.json
- tasks.json

##### JetBrains Toolbox

Заходим на сайт JetBrains в [раздел](https://www.jetbrains.com/toolbox-app/) загрузок продуктов. Выбираем нашу операционную систему и скачиваем архив \*.tar.gz . Затем распаковываем его командой `tar xvzf jetbrains-toolbox-xxx.tar.gz` В появившемся каталоге выполняем файл - это и есть JetBrains Toolbox.

В трее появляется значок программы и рядом открывается окно. Там первым делом логинимся и проверяем в открывшейся вкладке браузера какие у нас лицензии. Теперь просто щёлкаем по кнопкам установить на нужные нам продукты.

### Настройка окружения

#### Пути к основным каталогам $HOME

К основным каталогам в десктопной версии операционной системы относятся каталоги, в которых хранятся ресурсы разных видов (виде, аудио, картинки, документы), каталог, куда происхоит сохранение скачиваемых файлов, каталоги с общими ресурсами и шаблонами. На всех них по умолчанию ссылаются различные программы, которые задействуют файлы тех или иных видов. Поэтому было бы удобнее держать это в порядке.

Для этого есть конфигурационный файл `~/.config/user-dirs.dirs`. У меня рабочая его часть выглядит следующим образом:

```shell
XDG_DESKTOP_DIR="$HOME/Desktop"
XDG_DOWNLOAD_DIR="$HOME/Download"
XDG_TEMPLATES_DIR="$HOME/Templates"
XDG_PUBLICSHARE_DIR="$HOME/Share"
XDG_DOCUMENTS_DIR="$HOME/Documents"
XDG_MUSIC_DIR="$HOME/Music"
XDG_PICTURES_DIR="$HOME/Images"
XDG_VIDEOS_DIR="$HOME/Video"
XDG_PROJECTS_DIR="$HOME/Projects"
```

#### Установка и настройка ZSH

Мне вместо стандартной оболочки `Bash` больше нравится использовать оболочку `ZSH`.

В Ubuntu для установки нужно выполнить команду `sudo apt install zsh`. Для запуска оболочки выполняем команду `zsh`.

Для попадания в меню настроек, нажимаем клавишу **1**

1. Чтобы изменить **_количество команд_** (пункт 1), хранящихся в истории, нажимаем на **3** и вводим нужное количество
2. Для настройки **_автодополнения_** далее выбираем пункт **1** и всё останется по умолчанию
3. Далее выбираем **_стиль раскладки клавиатуры_** По умолчанию используется стиль _Emacs_. Но я, пожалуй, выберу _Vim_ (последовательность `3` -> `1` -> `v`).
4. Несколько дополнительных опций, которые можно включить или выключить (**s (set)** или **u (unset)**):
   1. **Change directory given just path** - смена рабочего каталога отличным от испльзования команды `cd` образом
   2. **Use additional pattern matching features** - разрешение на использование дополнительных символов для формирования шаблонов поиска (`#`, `~`, `^` кроме уже имеющихся `*` и `?`)
   3. **Unmatched patterns cause an error** - возвращать ли ошибку при отсутствии искомого вхождения
   4. **Beep on errors** - звуковой сигнал при ошибке
   5. **Immediately report changes in background job status** - сообщать об изменении статуса фоновых задач

В главном меню сохраняем изменения (`0` и ещё раз `0`). В файле `~/.zshrc` были изменены некоторые настройки. В этот файл можно добавлять псевдонимы, но настройки менять можно только через команду `zsh-newuser-install`. Даже кастовать приглашение для ввода лучше при помощи изменения переменной среды `PS1` и сохранением её командой `autoload -U colors && colors`.

##### Установка oh my zsh

Скрипт **oh my zsh** реализует множество дополнительных возможностей в zsh. Например можно выбрать тему из [списка](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes). Мне очень нравится тема **_amuse_**

Итак, **установка**:

```shell
curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh
```

Выполненный в домашней папке пользователя, этот скрипт установить все плагины и темы для zsh в `/home/<user>` и полностью заменит файл `./zshrc` на свой.

Для установки темы нужно открыть файл `./zshrc` и отредактировать настройку `ZSH_THEME`. В [описании](https://github.com/ohmyzsh/ohmyzsh/wiki/Themes) темы может быть информация о необходимости установки дополнительных шрифтов. Это можно сделать при помощи команды

```shell
sudo apt install fonts-powerline
```

##### Установка оболочки по умолчанию

Скорее всего введя команду `echo $SHELL` мы увидим следующий вывод `/bin/bash`. Это говорит о том, что при следующей загрузке, нужно будет снова выполнить команду `zsh`, чтобы пользоваться новой оболочкой. Сделаем же **ZSH** оболочкой по умолчанию. Для начала уточним, где была установлена оболочка командой `which zsh`, а потом выполним следующее:

```shell
chsh
Password:
Changing the login shell for p_boyko
Enter the new value, or press ENTER for the default
	Login Shell [/bin/bash]:

```

Вводим `/bin/zsh` (как результат `which zsh`) и, хотя команда `echo $SHELL` так и будет выводить `/bin/bash`, но при следующей загрузке системы текущий пользователь при выполнении этой же команды увидит zsh.

[Здесь](https://github.com/unixorn/awesome-zsh-plugins) есть инструкции по установке различных плагинов.

### Настройка интерфейса

#### Работа с клавиатурой

Самая первая проблема - это настройка раскладок клавиатуры. По умолчанию, почему-то переключение выключено. Поэтому заходим в **_Applications Menu_** -> **_Диспетчер настроек_** -> **_Оборудование:Клавиатура_** и во вкладке **_Раскладка_** отключаем "Использовать системные насеройки по умолчанию". Ниже выбираем в выпаающем меню **_Изменить параметры раскладки_** то сочетание клавиш, которое нам удобно.

Про "низкоуровневую" работу с клавиатурой [здесь](keyboard.md)

#### Работа с мониторами

XRandR — расширение X сервера, позволяющее производить настройки режимов работы мониторов. Для того, чтобы мне настроить мои мониторы в наиболее комфортном режим мне нужно ввести команду:

```shell
xrandr \
# Втсроенный дисплей ноутбука
--output LVDS-1 \
--off \               # отключаем дисплей
# Монитор BENQ EW3270ZL
--output HDMI-1 \
--primary \           # помечаем как основной монитор
--mode 1920x1080 \    # задаём разрешение
--pos 0x0 \           # позиционируем его относительно начала кооррдинат
--rotate normal       # задаём стандартное положение изображения
# Монитор HP L1750 - боковой
--output VGA-1 \
--mode 1024x768 \     # задаём разрешение
--pos 1920x0 \        # позиционируем его относительно начала кооррдинат
--rotate normal \     # задаём стандартное положение изображения
# В душе не представляю что это...
--output DP-1 \
--off                 # ...но это что-то отключено
```

Всё это нужно переписать в одну строчку и сохранить в файле `~/.xprofile` чтобы конфигурация сохранилась после перезагрузки или перелогинки.

#### Отключение блокировки экрана

`xset -dpms && xset s off`
