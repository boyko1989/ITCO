# Как работать над проектом
Всякое пердприятие можно запороть, если выбрать неправильный технический процесс. Разработка ПО - дело крайне сложное и запутанное. Оно только усложняется и запутывается с увеличением количества разработчиков и с разрастанием самого проекта. Поэтому нужно очень хорошо знать организацию труда.

При изучении системы контроля версий данное обстоятельство крайне важно так как она является способом смоделировать тех процесс. Для этого у неё есть специальный инструмент - ветки (**branch**). Так как система распределённая в полном смысле этого слова, то и в наших руках оказывается достаточно гибкий инструмент. Его мы можем применять по своему усмотрению. Но как и в любом деле, многолетняя практика позволяет перенять передовой опыт более успешных товарищей. Более того, сложилось несолько традиций. Здесь мы обозначим подход двух из них: Gitflow и магистральной разработки. Однако начнём с теории.
## Ветвление

Прежде, чем создавать новую ветку, нужно сделать снимок текущего состояния. Затем командой ```git branch -a``` проверяем какие ветки у нас уже созданы. Слежующий шаг - это создание ветки

```bash
$ git branch draft

$ git branch -a
  draft
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

$ git checkout draft
Switched to branch 'draft'
```
Есть нюанс: если мы закоммитим какие-то изменения, то при попытке запушить их из данной ветки выскочит ошибка:

```bash
fatal: The current branch draft has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin draft

To have this happen automatically for branches without a tracking
upstream, see 'push.autoSetupRemote' in 'git help config'.
```
Как из неё выйти тут же и написано. А заключается она в том, что команда ```push``` должна запускаться с опцией ```--set-upstream``` то есть с установленным потоком - знать она должна каким соединением пользоваться. Так и делаем. После этого на GitHub видим следующую картину:

![branch-protected.png](../../../img/branch-protected.png "\"Рождение\" локальной ветки на GitHub")
С pull request разберёмся позже, сейчас определимся с защитой ветки. Если наш аккаунт на GitHub - это коллективный аккаунт, то это возможность защитить основную ветку от "шаловливых" ручек или от случайных действий, которые могут повлечь потери времени и сил на исправление ошибок. Пока откажемся (Dismiss). В любой момент можно добавить правила защиты через *Settings* (В проекте) → *Code and automation* → *Branches* → *Branch protection rules*

### Ещё раз про HEAD и указатели.

Как говорилось ранее, HEAD - это указатель на коммит. Иначе его называют курсором GIT. Он определяет, в каком состоянии находится рабочая копия. На какой коммит указывает HEAD – из того коммита и загружаются файлы в рабочую директорию. 

Однако GIT позволяет создавать и другие ссылки. Если мы вручную передвигаем HEAD на один из непоследних коммитов, то у нас появляется указатель ORIG_HEAD, которой будет указывать на тот же коммит, на который указывал HEAD до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего).

Также мы можем создавать пользовательские указатели. Например, можно создать указатель, с именем соответствующим номеру версии и в случае необходимости переходить по названию коммита, а не по хэшу.

Делается это как-то спомощью команды ```git symbolic-ref <HEAD> <ref_name> ```. Но я создал отдельную ветку, которая к основной вообще никакого отношения не имеет. Разберусь с этим позже.

### Слияние, конфликты и их разрешение


## Методики работы над проектом

### Gitflow
####  Назначение веток внутри проекта

### Магистральная разработка

####  Назначение веток внутри проекта


Источники

https://smartiqa.ru/courses/git/lesson-3