# Взаимодействие локального и удалённого репозиториев

Будем подразумевать здесь, что в качестве удалённого сервера будет использоваться GitHub. Gitlab обладает гораздо более интересным функционалом, можно сделать свой git-сервер установив его на своём оборудовании или в облаке, есть API, который позволяет взимодействовать с сервером через CLI (создавать на сервере репозитории, раннеры, пайплайны и прочее)и много чего ещё, что обязательно рассмотрим в отдельной статье.

## SSH-ключи
<!-- [#3](https://github.com/boyko1989/ITCO/issues/3) fixed -->

Сгенерируем ключи:
```bash
ssh-keygen -t rsa -b 4096 -C "yourmail@example.com"
```
Я обычно прожимаю ```enter``` оставляя всё по-умолчанию. Что касается email, указанного здесь - это тот же, что мы ввели, при первоначальной настройке GIT. В Linux, по идее, можно обойтись и простой командой ```ssh-keygen``` - всё вполне неплохо будет работать.

Путь для сохранения ключей в случае пользования Windows - это ```C:/Users/<user>/.ssh/id_rsa```. Это нужно знать, так как дальше мы добавим ключи в SSH-агент. Убедимся, что он работает командой ```eval "$(ssh-agent -s)"```, на что мы должны получить его PID. Ну и, собственно, добавляем: ```ssh-add ~/.ssh/id_rsa```, если мы ничего не меняли в процессе генерации. В итоге должны получить победное:
```bash
Identity added: /c/Users/ВАШЕ_ИМЯ/.ssh/id_rsa (/c/Users/ВАШЕ_ИМЯ/.ssh/id_rsa)
```
Осталось только добавить ключи на GitHub. Для этого виндущятники открывают файл ```C:/Users/ВАШЕ_ИМЯ/.ssh/id_rsa.pub```, а Linux ```~/.ssh/id_rsa.pub```, и копируют его содержимое в аккаунте GitHub → (Правое верхнее меню) "*Settings*" → "*SSH and GPG keys*" → "*New SSH key*" → Поле "*Key*". Придумываем осмысленный *Title* и можем работать с удалённым репозиторием.

## Ещё раз о создании репозитория

В прошлой статье был рассмотрен вариант создания локального репозитория. В случае, если мы хотим его увидеть на удалённом git-хостинге, то нужно будет сделать следующее: во-первых, нужно создать пустой репозиторий на GitHub с именем, соответствующим имени локального репозитория. К сожалению, я не нашёл способ создать удалённый реп из терминала. Допустим, мы создаём репозиторий **testGit** у пользователя **boyko1989**. В таком случае нам нужно, чтобы в этом репозитории все файлы были зафиксированы. 

Следующий шаг - это добавление URL удалённого репозитория. Его можно взять из кнопки 'Code' на странице созданного пустого репозитория на GitHub. Следующая команда свяжет их:

```bash
git remote add origin git@github.com:boyko1989/testGit.git
git remote -v # Для проверки

origin  git@github.com:boyko1989/testGit.git (fetch)
origin  git@github.com:boyko1989/testGit.git (push)
```
Ну а дальше отправляем наши данные на сервер:
```bash
git push -u origin master
```

***Вопрос:*** что такое *origin*. Если просто, то на этом месте в команде определяется имя подключения к репозиторию. Конкретно origin - это основное подключение. Хотя мы можем в файлике ```.git/config``` (секцию remote, которого мы редактируем командой ```git remote ... ```) обозвать это подключение как нам будет угодно. 

Ну и всё: после этого мы можем видеть как содержимое нашего локального репозитория оказалось на сервере.

### Второй вариант создания репозитория

Это создание репозитория клонированием уже имеющегося удалённого. Технически - это не то чтобы прямо таки создание, но как частный случай мы можем его рассматривать. Делается просто: создаём репозиторий на GitHub, берём из кнопки 'Code' на странице репозитория URL (сейчас нужно брать ТОЛЬКО SSH) и на локальной машине в нужном месте открываем терминал GIT и вводим команду:

```bash
git clone git@github.com:boyko1989/testGit.git
```
Репозиторий в нашем распоряжении! Технически - оба варианта равнозначны. Какой нравится, или какой удобен, таким можно и пользоваться.

## Собственно, само взаимодействие

Есть два понятия PUSH и PULL, у которых перевод: "толкай" и "тяни", соответственно. Эта простая концепция, будет встречаться постоянно при построении взаимодействующих систем. Например, при использовании программы ```rsync```. 

Нужно понять, что есть два параметра - это **SRC** (source - "ресурс" или "источник") и **DST** (destination - "назначение") Кино такое было "Final destination" или ... Так вот, всё завист от того откуда куда идут байтики. И, как ни странно, на этом люди попадаются нередко - элементарно путают. Когда локальная машина - это **SRC**, значит происходит **PUSH**: мы байты ТОЛКАЕМ, соответственно, когда наоборот - мы их тянем.

Понятно, что необходимости в PUSHе каждый коммит нет. Польза, вред и идеальная частота определяется теми процессами, которые имеются в команде. Существет понятие **WorkFlow** или рабочий поток. Имеются отработанные процессы, которые наиболее применимы для работы. О них будет [следующая статья](scv3.md).